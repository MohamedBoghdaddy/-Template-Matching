# -*- coding: utf-8 -*-
"""Assignment 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x-OHzWc2TKI8POBUsk7ULrIa0jrnyX_F
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow

# Load the images
img_rgb = cv2.imread('mario.png')
template = cv2.imread('mario_coin3.png', 0)

# Check if the images are loaded successfully
if img_rgb is None or template is None:
    print("Error: Could not read one or both of the images.")
else:
    # Assignment Part 1: Rotation variant template matching
    def rotation_variant_template_matching(img, template):
        img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Create rotated versions of the template for matching
        angles = np.arange(0, 360, 15)
        detections = []

        for angle in angles:
            rotated_template = cv2.rotate(template, cv2.ROTATE_90_CLOCKWISE)

            # Apply template matching to the rotated template
            res_rotated = cv2.matchTemplate(img_gray, rotated_template, cv2.TM_CCOEFF_NORMED)

            # Set a threshold for matches
            threshold_rotated = 0.8
            loc_rotated = np.where(res_rotated >= threshold_rotated)

            for pt_rotated in zip(*loc_rotated[::-1]):
                detections.append(pt_rotated)

        # Draw rectangles on the original image
        img_detection = img.copy()
        for pt_rotated in detections:
            cv2.rectangle(img_detection, pt_rotated, (pt_rotated[0] + template.shape[1], pt_rotated[1] + template.shape[0]), (0, 255, 0), 2)

        return img_detection

    # Assignment Part 2: Scale variant template matching
    def scale_variant_template_matching(img, template):
        img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Define a scale range
        scales = np.linspace(0.5, 2.0, 10)
        detections = []

        for scale in scales:
            # Resize the template based on the scale
            scaled_template = cv2.resize(template, (int(scale * template.shape[1]), int(scale * template.shape[0])))

            # Apply template matching
            res = cv2.matchTemplate(img_gray, scaled_template, cv2.TM_CCOEFF_NORMED)

            # Set a threshold for matches
            threshold = 0.8
            loc = np.where(res >= threshold)

            for pt in zip(*loc[::-1]):
                detections.append(pt)

        # Draw rectangles on the original image
        img_detection = img.copy()
        for pt in detections:
            cv2.rectangle(img_detection, pt, (pt[0] + template.shape[1], pt[1] + template.shape[0]), (0, 255, 0), 2)

        return img_detection

    # Assignment Part 3: Multi-object detection
    def multi_object_detection(img, template):
        img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Apply template matching
        res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)

        # Set a threshold for matches
        threshold = 0.8
        loc = np.where(res >= threshold)

        detections = []

        for pt in zip(*loc[::-1]):
            detections.append(pt)

        # Draw rectangles on the original image
        img_detection_multi = img.copy()
        for pt in detections:
            cv2.rectangle(img_detection_multi, pt, (pt[0] + template.shape[1], pt[1] + template.shape[0]), (0, 255, 0), 2)

        return img_detection_multi

    # Display the results
    img_detection_rotation = rotation_variant_template_matching(img_rgb, template)
    img_detection_scale = scale_variant_template_matching(img_rgb, template)
    img_detection_multi = multi_object_detection(img_rgb, template)

    # Display the results using cv2_imshow
    print("Rotation Variant Template Matching:")
    cv2_imshow(img_detection_rotation)

    print("Scale Variant Template Matching:")
    cv2_imshow(img_detection_scale)

    print("Multi-Object Detection:")
    cv2_imshow(img_detection_multi)